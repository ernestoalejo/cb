package v0

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/ernestokarim/cb/config"
	"github.com/ernestokarim/cb/registry"
	"github.com/kylelemons/go-gypsy/yaml"
)

func init() {
	registry.NewUserTask("validator", 0, validatorTask)
}

type field struct {
	Key, Kind, Store, Condition string
	Validators                  []*validator
	Fields                      []*field
}

type validator struct {
	Name, Value string
	Uses        []string
}

func validatorTask(c *config.Config, q *registry.Queue) error {
	rootPath := "../app/validators"
	walkFn := func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			return nil
		}

		// Relative path
		rel, err := filepath.Rel(rootPath, path)
		if err != nil {
			return fmt.Errorf("cannot rel validator path: %s", err)
		}

		// Read file
		f, err := yaml.ReadFile(path)
		if err != nil {
			return fmt.Errorf("read validator failed: %s", err)
		}
		data := config.NewConfig(f)

		// Extract fields
		root := data.GetDefault("root", "Object")
		if root != "Object" && root != "Array" {
			return fmt.Errorf("invalid root type, only 'object' and 'array' are accepted")
		}
		fields := parseFields(data, "fields")

		// Generate validator
		if err := generator(rel, root, fields); err != nil {
			return fmt.Errorf("generator error: %s", err)
		}

		return nil
	}
	if err := filepath.Walk(rootPath, walkFn); err != nil {
		return fmt.Errorf("walk validators failed: %s", err)
	}

	return nil
}

// ==================================================================

func parseFields(data *config.Config, spec string) []*field {
	fields := []*field{}

	size := data.CountRequired("%s", spec)
	for i := 0; i < size; i++ {
		field := &field{
			Key:        data.GetDefault("%s[%d].key", "", spec, i),
			Kind:       data.GetRequired("%s[%d].kind", spec, i),
			Store:      data.GetDefault("%s[%d].store", "", spec, i),
			Condition:  data.GetDefault("%s[%d].condition", "", spec, i),
			Validators: make([]*validator, 0),
		}

		if field.Kind == "Array" || field.Kind == "Object" || field.Kind == "Conditional" {
			newSpec := fmt.Sprintf("%s[%d].fields", spec, i)
			field.Fields = parseFields(data, newSpec)
		}

		validatorsSize := data.CountDefault("%s[%d].validators", spec, i)
		for j := 0; j < validatorsSize; j++ {
			v := &validator{
				Name:  data.GetRequired("%s[%d].validators[%d].name", spec, i, j),
				Value: data.GetDefault("%s[%d].validators[%d].value", "", spec, i, j),
			}

			usesSize := data.CountDefault("%s[%d].validators[%d].use", spec, i, j)
			for k := 0; k < usesSize; k++ {
				value := data.GetDefault("%s[%d].validators[%d].use[%d]", "", spec, i, j, k)
				v.Uses = append(v.Uses, value)
			}

			field.Validators = append(field.Validators, v)
		}

		fields = append(fields, field)
	}

	return fields
}

// ==================================================================

type emitter struct {
	f           io.Writer
	indentation int
	uses        []string
	id          int
}

func (e *emitter) indent() {
	e.indentation += 2
}

func (e *emitter) unindent() {
	e.indentation -= 2
}

func (e *emitter) addUse(use string) {
	for _, u := range e.uses {
		if u == use {
			return
		}
	}
	e.uses = append(e.uses, use)
}

func (e *emitter) emitf(format string, a ...interface{}) {
	for i := 0; i < e.indentation; i++ {
		fmt.Fprint(e.f, " ")
	}
	fmt.Fprint(e.f, fmt.Sprintf(format, a...))
	fmt.Fprintln(e.f)
}

func (e *emitter) arrayID() int {
	id := e.id
	e.id++
	return id
}

// ==================================================================

func generator(original, root string, fields []*field) error {
	namespace := "\\" + strings.Replace(filepath.Dir(original), "/", "\\", -1)
	filename := filepath.Base(original)
	filename = filename[:len(filename)-len(filepath.Ext(original))]
	name := strings.Replace(strings.Title(filename), "-", "", -1)
	destPath := filepath.Join("..", "app", "lib", "Validators", filepath.Dir(original), name+".php")

	if err := os.MkdirAll(filepath.Dir(destPath), 0755); err != nil {
		return fmt.Errorf("cannot create dest path: %s", err)
	}

	f, err := os.Create(destPath)
	if err != nil {
		return fmt.Errorf("cannot create dest file: %s", err)
	}
	defer f.Close()

	buf := bytes.NewBuffer(nil)
	e := &emitter{f: buf, indentation: 4}

	if root == "Object" {
		if err := generateObject(e, "data", "valid", fields); err != nil {
			return fmt.Errorf("generate object fields failed: %s", err)
		}
	} else if root == "Array" {
		if err := generateArray(e, "data", "valid", fields); err != nil {
			return fmt.Errorf("generate array fields failed: %s", err)
		}
	}

	var uses string
	for _, use := range e.uses {
		uses += "\nuse " + use + ";"
	}

	fmt.Fprintf(f, `<?php namespace Validators%s;
// AUTOGENERATED BY cb FROM %s, PLEASE, DON'T MODIFY IT

use App;
use Input;
use Log;
use Str;
%s

class %s {

  public static function validateJson() {
    return self::validateData(Input::json()->all());
  }

  public static function validateInput() {
    return self::validateData(Input::all());
  }

  public static function error($data, $msg) {
    $bt = debug_backtrace();
    $caller = array_shift($bt);
    Log::error($msg);
    Log::debug($caller['file'] . '::' . $caller['line']);
    Log::debug(var_export($data, TRUE));
    App::abort(403, 'validator error');
  }

  public static function validateData($data) {
    $valid = array();
    $store = array();

    if (!is_array($data)) {
      self::error($data, 'root is not an array');
    }

%s
    if (!$valid) {
      Log::warning('$valid is not evaluated to true');
      Log::debug(var_export($data, TRUE));
      Log::debug(var_export($valid, TRUE));
      App::abort(403);
    }
    return $valid;
  }

}

`, namespace, original, uses, name, buf.String())
	return nil
}

func generateObject(e *emitter, varname, result string, fields []*field) error {
	for _, f := range fields {
		f.Key = "'" + f.Key + "'"

		if f.Kind != "Conditional" {
			e.emitf(`if (!isset($%s[%s])) {`, varname, f.Key)
			e.emitf(`  $%s[%s] = null;`, varname, f.Key)
			e.emitf(`}`)
		}

		if err := generateField(e, f, varname, result); err != nil {
			return fmt.Errorf("generate field failed: %s", err)
		}
		if f.Kind != "Conditional" && f.Kind != "Array" {
			if err := generateValidations(e, f); err != nil {
				return fmt.Errorf("generate validators failed: %s", err)
			}

			if f.Kind != "Object" {
				e.emitf(`$%s[%s] = $value;`, result, f.Key)
			}
		}
		e.emitf("")
	}
	return nil
}

func generateArray(e *emitter, varname, result string, fields []*field) error {
	id := e.arrayID()
	e.emitf("$size%d = count($%s);", id, varname)
	e.emitf("for ($i%d = 0; $i%d < $size%d; $i%d++) {", id, id, id, id)
	e.indent()
	e.emitf(`if (!isset($%s[$i%d])) {`, varname, id)
	e.emitf(`  self::error($data, 'array has not key ' . $i%d);`, id)
	e.emitf(`}`)

	for _, f := range fields {
		f.Key = fmt.Sprintf("$i%d", id)

		if err := generateField(e, f, varname, result); err != nil {
			return fmt.Errorf("generate field failed: %s", err)
		}
		if f.Kind != "Conditional" && f.Kind != "Array" {
			if err := generateValidations(e, f); err != nil {
				return fmt.Errorf("generate validators failed: %s", err)
			}

			if f.Kind != "Object" {
				e.emitf(`$%s[%s] = $value;`, result, f.Key)
			}
		}
		e.emitf("")
	}

	e.unindent()
	e.emitf("}")
	return nil
}

func generateField(e *emitter, f *field, varname, result string) error {
	switch f.Kind {
	case "String":
		e.emitf(`$value = $%s[%s];`, varname, f.Key)
		e.emitf(`if ($value === null) {`)
		e.emitf(`  $value = '';`)
		e.emitf(`}`)
		e.emitf(`if (is_int($value)) {`)
		e.emitf(`  $value = strval($value);`)
		e.emitf(`}`)
		e.emitf(`if (!is_string($value)) {`)
		e.emitf(`  self::error($data, 'key ' . %s . ' is not a string');`, f.Key)
		e.emitf(`}`)

	case "Integer":
		e.emitf(`$value = $%s[%s];`, varname, f.Key)
		e.emitf(`if ($value === null) {`)
		e.emitf(`  $value = 0;`)
		e.emitf(`}`)
		e.emitf(`if (is_string($value)) {`)
		e.emitf(`  if (!ctype_digit($value)) {`)
		e.emitf(`    self::error($data, 'key ' . %s . ' is not a valid int');`, f.Key)
		e.emitf(`  }`)
		e.emitf(`  $value = intval($value);`)
		e.emitf(`}`)
		e.emitf(`if (!is_int($value)) {`)
		e.emitf(`  self::error($data, 'key ' . %s . ' is not an int');`, f.Key)
		e.emitf(`}`)

	case "Boolean":
		e.emitf(`$value = $%s[%s];`, varname, f.Key)
		e.emitf(`if (is_string($value)) {`)
		e.emitf(`  if ($value === 'true' || $value === '1' || $value === 'on') {`)
		e.emitf(`    $value = true;`)
		e.emitf(`  }`)
		e.emitf(`  if ($value === 'false' || $value === '0' || $value === 'off') {`)
		e.emitf(`    $value = false;`)
		e.emitf(`  }`)
		e.emitf(`}`)
		e.emitf(`if (!is_bool($value)) {`)
		e.emitf(`  self::error($data, 'key ' . %s . ' is not a boolean');`, f.Key)
		e.emitf(`}`)

	case "Object":
		e.emitf(`$value = $%s[%s];`, varname, f.Key)
		e.emitf(`if (!is_array($value)) {`)
		e.emitf(`  self::error($data, 'key ' . %s . ' is not an object');`, f.Key)
		e.emitf(`}`)
		e.emitf(`$%s[%s] = array();`, result, f.Key)
		e.emitf("")

		name := fmt.Sprintf("%s[%s]", varname, f.Key)
		res := fmt.Sprintf("%s[%s]", result, f.Key)
		if err := generateObject(e, name, res, f.Fields); err != nil {
			return fmt.Errorf("generate object failed: %s", err)
		}

	case "Array":
		e.emitf(`$value = $%s[%s];`, varname, f.Key)
		e.emitf(`if (is_null($value)) {`)
		e.emitf(`  $value = array();`)
		e.emitf(`}`)
		e.emitf(`if (!is_array($value)) {`)
		e.emitf(`  self::error($data, 'key ' . %s . ' is not an array');`, f.Key)
		e.emitf(`}`)
		e.emitf(`$%s[%s] = array();`, result, f.Key)
		e.emitf("")

		if err := generateValidations(e, f); err != nil {
			return fmt.Errorf("generate validators failed: %s", err)
		}

		name := fmt.Sprintf("%s[%s]", varname, f.Key)
		res := fmt.Sprintf("%s[%s]", result, f.Key)
		if err := generateArray(e, name, res, f.Fields); err != nil {
			return fmt.Errorf("generate array failed: %s", err)
		}

	case "Conditional":
		if len(f.Condition) == 0 {
			return fmt.Errorf("conditional node needs a condition")
		}

		e.emitf(`if (%s) {`, f.Condition)
		e.indent()

		if err := generateObject(e, varname, result, f.Fields); err != nil {
			return fmt.Errorf("generate object failed: %s", err)
		}

		e.unindent()
		e.emitf(`}`)

	default:
		return fmt.Errorf("`%s` is not a valid field kind", f.Kind)
	}

	if f.Store != "" {
		e.emitf(`$store['%s'] = $value;`, f.Store)
	}

	return nil
}
